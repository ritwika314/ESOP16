\section{Overview of Language and System}
\label{sect:Overview}
In this section, we give an overview of the system architecture within which \rolang programs execute and then discuss key language features with an example.

We call an entity executing a \rolang program an {\em agent\/} or a {\em process.\/}
The hardware abstraction on which \rolang programs executes includes (a) a controller, (b) shared memory, in addition to the usual (c) local memory and processing unit of the agent.  
%
The controller receives lists of way-points and obstacles from the agent's program, drives the actuators (e.g. motors) to reach the way-points while avoiding the obstacles using sensors (e.g. GPS), and updates certain flags to indicate its status to the program.
%
The shared memory abstraction provides single-writer and multi-writer distributed shared variables using which an agent's program can communicate with another agent's program. 

%A \rolang program interacts with 
\begin{figure}[t!]
	\centering
	\includegraphics[scale=0.4]{figs/arch.png}
	\caption{\small Architecture of distributed system. Agent programs interact through shared variables. Each agent program also sets waypoints for its own controller which control the physical motion of the agent's platform. The agent platforms inhabit a shared physical environment, and therefore, also interact physically.}
\end{figure}

%\rolang allows users to write applications that will run on a distributed system of agents. 
For this paper, we assume that all agents execute the same \rolang program. A program is a collection of \emph{variable declarations} and \emph{events}. 
The language provides two types of shared variables:
(a) a {\em multi-writer} shared variable $x$ is declared as $\MW$ and allows all agents to do reads and writes on $x$. 
(b) a {\em single-writer\/} shared variable $x$ is declared as $\SW$ block, and it 
creates an array $x\langle \cdot \rangle$ 
where the $i^{th}$ component $x \langle i \rangle$ can be read by all but can only be written to by agent $i$.
%Local variables are declared in \verb|Loc|al declaration blocks.  \newline

As mentioned earlier, \rolang uses a \emph{precondition-effect} style of programming. These precondition and effect statements form events. Each application consists of a special \verb|Init| event, and an \verb|EventBlock|. The \verb|Init| event occurs at the beginning when the application starts executing, and it contains all statements which need to be executed only once; for instance, initializing a shared array. After the \verb|Init| event is executed, the \verb|EventBlock| starts executing. It contains a list of events that define the behavior of the application. The preconditions of each of the events inside the \verb|EventBlock| are evaluated in order of appearance, and the effect is executed if the precondition becomes true. The \verb|EventBlock| can be seen as a (potentially) infinite while-loop. 

We also provide an abstraction to manage the physical control of the agents, called \verb|doReach|, which takes as input a \emph{target} to reach, and a list of (predetermined) \emph{obstacles} which need to be avoided. We do not need to specify the format of the obstacles, as different implementations of this \verb|doReach| can have different specifications, but the target in general has the same type as the time varying variables of the system. \verb|doReach| communicates with the program using two flags, \emph{doReach_done}, and \emph{doReach_fail}. If the target is reached, the \emph{doReach_done} is set to true, and the \emph{doReach_fail} is set to true when the agent does not seem to have reached the target.

The next section presents the formal syntax, and an example to illustrate the structure of a general application. 

\input{syntax.tex}