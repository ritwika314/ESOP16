\subsection{The \textbf{K} Framework}
\K~\cite{rosu-serbanuta-2013-k} is a rewrite-based executable framework for defining language semantics.
Given a syntax and a semantics of a language, \K generates a parser, an interpreter, as well as formal analysis tools such as model checkers and deductive program verifiers at no additional cost.
\K also provides several formal analysis tools, which will enable us to perform formal reasoning about the language we have defined using this framework. 

This helps both in terms of applicability of the semantics and in terms of engineering the semantics itself; for instance, the state-space exploration capability helps the language designer cover all the non-deterministic behaviors of certain language constructs or combinations of them in the language definition.

We briefly describe \K here. In \K, a language syntax is defined using conventional Backus-Naur Form (BNF).
A language semantics is given as a transitions system, specifically a set of reduction rules over configurations.
A configuration is an algebraic representation of the program code and state.
Intuitively, it is a tuple whose elements (i.e. cells) are labeled and possibly nested. 
Each cell represents a semantic component such as store, environment and thread that is used in the semantics.
A special cell, named \s{k}, contains a list of computation to be executed.
A computation is a program fragment, while the original program is flattened into a sequence of computations or programming tasks.
A rule describes a one-step transition between configurations.
Rules are modular; they mention only relevant cells needed in each rule.
The cells are represented with angle brackets notation.
The horizontal line represents a reduction (i.e. a transition relation).
A cell with no horizontal line means that it is read but not changed by the rule.

To model the behaviors and interactions between agents, an appealing aspect of \K is its inherent support for non-determinism.
As \K is based on rewriting logic \cite{meseguer2007rewriting}, one can easily define, execute, and reason about non-deterministic specifications in \K. 
\K can capture non-deterministic features both related to concurrency and to the order of evaluation. 